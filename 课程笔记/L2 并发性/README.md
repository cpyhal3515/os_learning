# L2 并发性

## 基本概念
### 线程
* 线程：每个线程都有一个程序计数器（PC）来跟踪程序获取指令的位置以及自己独立的寄存器用于计算。因此，如果在单个处理器上同时运行两个线程，当处理器从线程（T1）切换到另一个线程（T2）时，必须进行上下文切换。在运行 T2 之前必须保存 T1 寄存器的状态并恢复 T2 寄存器状态，从这个角度来看线程与进程是十分相似的。但是 **线程共享地址空间**，因此在切换过程中不需要切换正在使用的页表。下面的图中，左边是单线程，右边是多线程，堆栈分配的变量、参数、返回值等被放在对应线程的堆栈中：
<center><img src=./picture/image1.png width=80% /></center>

### 使用多线程的原因？
* Reason 1：将任务并行处理，加速运算。
* Reason 2：避免相较于 CPU 慢得多的 I/O 操作阻塞程序运行。当程序中的一个线程阻塞等待 I/O 时，CPU调度器可以切换到其他线程运行。

上面的情况也可以使用多进程而不是多线程，但是对于需要共享数据的任务来说，多线程可以共享一个地址空间，使共享数据变得容易。对于逻辑上独立的任务来说，它们很少需要共享内存中的数据结构，因此进程是一个更合理的选择。

### 多线程带来的麻烦
* 例子：在下面的程序中两个线程同时增加 counter 的计数结果，多次运行可以得到最终 counter 的值为 19345221、19221041 等，值不稳定，且大部分情况下不等于 20000000。
    ```c
    static volatile int counter = 0;

    // 每次给 counter 加一
    void *mythread(void *arg) 
    {
        int i;
        for (i = 0; i < 1e7; i++)
            counter = counter + 1;
        return NULL;
    }

    // 同时运行两个线程
    int main(int argc, char *argv[]) 
    {
        pthread_t p1, p2;
        printf("main: begin (counter = %d)\n", counter);
        Pthread_create(&p1, NULL, mythread, "A");
        Pthread_create(&p2, NULL, mythread, "B");

        // 等待两个线程运行结束
        Pthread_join(p1, NULL);
        Pthread_join(p2, NULL);
        printf("main: done with both (counter = %d)\n",counter);
        return 0;
    }
    
    ```
* 对上面的代码进行反汇编可以得到 `counter = counter + 1` 部分对应的代码为：
    ```asm
    mov 0x8049a1c, %eax
    add $0x1, %eax
    mov %eax, 0x8049a1c
    ```
    counter 位于地址 0x8049a1c。在实现加法的过程中，首先使用 `mov` 指令获取地址处的内存值，并将其放入寄存器 `eax` 中。然后，执行 `add` 操作，给 `eax` 寄存器加 1。最后，将 `eax` 的内容存储回相同地址的内存中。

    如果 Thread1 刚运行完 `add $0x1, %eax` 后被切换，换 Thread2 来运行，由于 Thread1 并没有将计算结束的寄存器值写回内存中，Thread2 拿到的寄存器的值就是原来的，再加一后写回寄存器，Thread2 执行结束，再换回 Thread1，Thread1 直接往内存里写入自己寄存器里面的值，相当于覆盖了 Thread2 刚写入内存的值，而不是完成了两次加法，这就出现了问题。

* 根源：线程的调度是不受控制的。线程是并发运行的，因此如果有两个线程 Thread1 以及 Thread2 时，我们不知道会先运行 Thread1 还是 Thread2，也不知道会不会在运行 Thread1 运行到一半之后被切换出去转而运行 Thread2。更严谨的来说，执行此代码的多个线程可能导致竞争，因此我们将此段代码称为临界区 (critical section)。临界区是访问共享变量（或者更一般地说，共享资源）的一段代码，不能由多个线程并发执行。

**我们需要代码是互斥的，也就是说如果一个线程在临界区内执行，其他线程将被阻止，这样保证计算结果的确定性。** 

* 解决上述问题的方法很简单，就是保证 `counter = counter + 1` 是原子的（atomicity），中间不会被打断的，因此之后会讲到同步原语（synchronization primitives）。

### 多线程需要解决的问题
* Problem1：对于临界区问题，保证互斥性，锁会被用来解决这个问题。
* Problem2：线程之间的等待问题，比如 Thread1 必须等 Thread2 结束之后才能运行，当程序执行 I/O 磁盘交互的过程中，程序处于睡眠状态，当 I/O 结束后需要将程序从休眠状态中唤醒，以便继续运行，条件变量会被用来解决这个问题。

## 锁
### 锁的基本概念
* 锁实际上就是通过一个变量锁住临界区，保证同一时刻仅能有一个线程进入临界区，本质就是实现临界区一段代码整体的原子化。
    ```c
    lock_t mutex;
    ...
    lock(&mutex);
    balance = balance + 1;
    unlock(&mutex);
    ```
> 锁为程序员提供了对调度的最小控制。一般情况下，我们将线程视为由程序员创建但由操作系统调度的实体。锁将部分控制权交还给程序员，通过给一段代码加上锁，程序员可以保证在这段代码中活动的线程不超过一个。因此，锁有助于将传统操作系统调度中相对混乱的流程转变为更受控制的活动。
### 锁的实现
#### 锁的要求
* Require 1：要实现基本功能——提供互斥性。
* Require 2：要保证一定的公平性，尽量减少线程的饥饿现象。
* Require 3：要保证性能，特别是使用锁所增加的时间开销。
    * 当一个运行中的线程获取和释放锁时带来的开销。
    * 单一 CPU 的情况下，多个线程征用同一个锁时的性能问题。
    * 多个 CPU 的情况下，每个 CPU 上的线程都争用锁时，锁的执行情况。
#### Method 1：控制中断
* 在进入临界区之前关闭中断(使用某种特殊的硬件指令)，从而确保临界区内的代码不会被中断，进而实现原子性。当临界区的代码执行结束后，我们重新启用中断(同样，通过硬件指令)，程序照常进行。逻辑代码如下所示：
    ```c
    void lock() 
    {
        DisableInterrupts();
    }
    void unlock() 
    {
        EnableInterrupts();
    }
    ```

* 优点
    * 简单  
* 缺点
    * 每个线程都能自己开关中断，相当于给每个应用程序以内核权限了，较为危险。
    * 多处理时无法使用。因为仅能关闭单个处理器的中断，其它的处理器上的线程还是可能同步进入临界区。
    * 可能导致中断丢失，比如在 CPU 中断被关掉的过程中，磁盘设备来了一个读请求中断，这个中断就会被丢失。
#### Method 2：自旋锁
* 自旋锁可以基于下面这样一段代码：
    ```c
    // 返回旧值，同时将旧值更新为新值
    int TestAndSet(int *old_ptr, int new) 
    {
        int old = *old_ptr;
        *old_ptr = new;
        return old;
    }
    ```
* 给出自旋锁的实现：
    ```c
    typedef struct __lock_t 
    {
        int flag;
    } lock_t;

    void init(lock_t *lock) 
    {
        // 0: 锁可用, 1: 锁以及被持有
        lock->flag = 0;
    }

    void lock(lock_t *lock) 
    {
        // 自旋等待
        while (TestAndSet(&lock->flag, 1) == 1);
    }

    void unlock(lock_t *lock) 
    {
        lock->flag = 0;
    }
    ```

    * 当前没有其它线程持有锁的时候，一个线程调用 `lock()`，flag 应该是 0。当线程调用 `TestAndSet(flag, 1)` 时，将返回 0，因此，该调用线程将获得锁，并且将该值设置为 1，从而表示锁现在已被持有。当线程结束其临界区代码的执行后，它调用 `unlock()` 将标志设置为零。
    * 在一个线程已经持有锁的情况下，这个线程将调用 `lock()`，然后调用 `TestAndSet(flag, 1)`，该函数将返回标志处的旧值 1 (因为锁被持有)，同时再次将其设置为 1。只要锁被另一个线程持有，该函数就会反复返回1，因此这个线程会一直旋转，直到锁最终被释放。当其他线程最终将该标志设置为 0 时，该线程再次调用 `TestAndSet()`，返回 0，同时自动将值设置为 1，从而获得锁并进入临界区。

* 缺点
    * 无法保证公平性。
    * 在单 CPU 上的性能较差（如果一个在临界区的线程被切换出去，那就会造成这把锁长时间无法交回，别的线程都在空转等锁）。




### POSIX 的锁
```c
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

Pthread_mutex_lock(&lock);
balance = balance + 1;
Pthread_mutex_unlock(&lock);
```


## 条件变量

## 信号量


